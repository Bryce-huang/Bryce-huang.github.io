<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/blog/crown.png"><link rel="icon" type="image/png" href="/img/blog/crown.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="description" content="Nothing is so common as the wish to be remarkables"><meta name="author" content="Bryce Huang"><meta name="keywords" content="blog,program,life"><title>JVM学习笔记 - Bryce&#39;s Club</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/dracula.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css"><link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bryce's Club" type="application/atom+xml"></head><body><div id="dark" onclick="switchDarkMode()"></div><script>var isNight=18<=(new Date).getHours()||(new Date).getHours()<8;(matchMedia("(prefers-color-scheme: dark)").matches||isNight||"1"===localStorage.getItem("dark"))&&(isNight&&"1"===localStorage.getItem("noDark")||document.body.classList.add("dark")),document.getElementById("dark").innerHTML=document.querySelector("body").classList.contains("dark")?"🌙":"🌞"</script><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>Bryce's Club</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item"><a class="nav-link" href="/messageboard/"><i class="iconfont icon-speakernotes"></i> 留言</a></li><li class="nav-item"><a class="nav-link" href="/features/"><i class="iconfont icon-exp-fill"></i> 功能</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/img/star-guardian/champion-pajama-group-splash.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><div class="mt-3 post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2019-06-04 09:23">星期二, 六月 4日 2019, 9:23 上午</time></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 127 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><div class="post-content mx-auto" id="post"><article class="markdown-body"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因工作上涉及到jvm内存管理，这一块内容因使用的不多，以前了解的知识差不多都忘光了，但目前需要简单地针对当前应用进行调优和内存压缩。故简单学习下jvm，基于《深入立即Java虚拟机》学习，做一部分笔记，如果对你有帮助，不胜荣幸。</p><h2 id="jvm种类和历史"><a href="#jvm种类和历史" class="headerlink" title="jvm种类和历史"></a>jvm种类和历史</h2><p>常用的jvm有sun公司的Hotspot和eba公司的JRockit（均被oracle收购了）以及IBM公司的j9。都是相当常用的虚拟机。目前大众使用的oracle的jdk使用的应该是Hotspot虚拟机。其中有许多语言建立在jvm虚拟机上，如果可以深入学习jvm虚拟机，则可以触类旁通，窥一斑而见全豹。针对kotlin和groovy以及Scala虚拟机都有一定认识。</p><h2 id="jvm内存分布"><a href="#jvm内存分布" class="headerlink" title="jvm内存分布"></a>jvm内存分布</h2><p>说到jvm对于普通开发者来说，最重要的就是内存调优。jdk1.7和jdk1.8以后内存有较大的区别。其中无论是1.7还是1.8都移除了字符串常量池。</p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>java虚拟机运行时，会将它所管理的内存划分若干用途不同的数据区域。如图：<img src="/images/jvmruntimearea.webp" alt="运行时数据区"></p><ul><li>程序计数器（Program Counter Register）：字节码解释器工作通过改变这个计数器的值来选取下一个需要执行的字节码指令，分支、跳转、异常处理、线程恢复等基础功能都依赖此。</li><li>java虚拟机栈（Java virtual machine stacks）：线程私有，生命周期与线程相同，描述的是Java方法执行的内存模型：每一个方法执行的同时都会创建一个栈帧（Stack Frame），由于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法的执行就对应着栈帧在虚拟机栈中的入栈，出栈过程。</li><li>本地方法栈（native method stack）：与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机剋有自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</li><li>Java堆（Java heap）：对于大部分应用来说，Java堆是Java虚拟机所管理的内存最大的一块。Java堆被所有线程共享，此内存区域就是存放对象实例。</li><li>方法区（method area）：同样被各线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量，即时编译器编译后的代码。Java虚拟机规范把方法区描述为堆的一个逻辑部分。</li><li><del>运行时常量池（runtime contant pool）：已废弃不介绍了。</del></li><li>直接内存（direct memory）：直接内存并不是虚拟机运行时数据区的一部分 -Xmx并无法限制字节内存。</li><li>元空间（Metaspace）：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：<code>-XX:MetaspaceSize</code>，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过<em>MaxMetaspaceSize</em>时，适当提高该值。<br>　　<code>-XX:MaxMetaspaceSize</code>，最大空间，默认是没有限制的。<br>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：<br>　　<code>-XX:MinMetaspaceFreeRatio</code>，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集<br><code>-XX:MaxMetaspaceFreeRatio</code>，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</li></ul><h3 id="java中的引用"><a href="#java中的引用" class="headerlink" title="java中的引用"></a>java中的引用</h3><p>什么是引用？ 如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>指在程序代码之中普遍存在的，类似于<code>Object obj=new Object()</code>,这类引用只要还存在，垃圾收集器就不会回收掉被引用的对象。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用就是用来描述一些还有用但是并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出的异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收内存仍然不足，才会抛出内存溢出的异常。jdk1.2之后引入SoftReference类来实现。</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>也是用来描述非必须对象的，但是他的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存是否够用都会收集，jdk1.2之后引入WeakReference类来实现。</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知，jdk1.2后引入PhantomReference类来实现虚引用。</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>类从被加载到JVM中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。</p><p>其中类加载过程包括加载、验证、准备、解析和初始化五个阶段。</p><p><img src="/images/classloadprocess.webp" alt="类加载过程"></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>这个很简单，程序运行之前jvm会把编译完成的.class二进制文件加载到内存，供程序使用，用到的就是类加载器classLoader ，这里也可以看出java程序的运行并不是直接依 靠底层的操作系统，而是基于jvm虚拟机。如果没有类加载器，java文件就只是磁盘中的一个普通文件。</p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>连接是很重要的一步，过程比较复杂，分为三步 验证 &gt;准备 &gt;解析。</p><ol><li>验证：确保类加载的正确性。一般情况由javac编译的class文件是不会有问题的，但是可能有人的class文件是自己通过其他方式编译出来的，这就很有可能不符合jvm的编 译规则，这一步就是要过滤掉这部分不合法文件</li><li>准备：为类的静态变量分配内存，将其初始化为默认值 。我们都知道静态变量是可以不用我们手动赋值的，它自然会有一个初始值 比如int 类型的初始值就是0 ；boolean类型初始值为false，引用类型的初始值为null 。 这里注意，只是为静态变量分配内存，此时是没有对象实例的</li><li>解析：把类中的符号引用转化为直接引用。解释一下符号引用和直接引用。比如在方法A中使用方法B，A（）{B（）；}，这里的B（）就是符号引用，初学java时我们都是知道这是java的引用，以为B指向B方法的内存地址，但是这是不完整的，这里的B只是一个符号引用，它对于方法的调用没有太多的实际意义，可以这么认为，他就是给程序员看的一个标志，让程序员知道，这个方法可以这么调用，但是B方法实际调用时是通过一个指针指向B方法的内存地址，这个指针才是真正负责方法调用，他就是直接引用。</li></ol><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值</p><h4 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h4><p>不像类加载，Java中没有提供显式进行类卸载的API，但是如果加载类的ClassLoader对象被垃圾回收器回收的话，这个类就会被卸载。所以我们可以自己实现ClassLoader，自己加载类，然后对ClassLoader对象的引用赋值为null，等ClassLoader对象剩下的引用数量为0时会被回收，这样就达到卸载类的目的了。</p><h2 id="垃圾收集器与收集算法"><a href="#垃圾收集器与收集算法" class="headerlink" title="垃圾收集器与收集算法"></a>垃圾收集器与收集算法</h2><p>java和c++有一道关于内存回收的高墙，墙外的人想进去，墙内的人想去。世界总是平衡的。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最基础的收集算法是“标记-清除”(Mark-Sweep)算法，分两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>不足：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致以后在程序运行过程需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一个的垃圾收集动作。</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率问题，一种称为复制(Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上，然后再把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。代价是内存缩小为原来的一半。</p><p>商业虚拟机用这个回收算法来回收新生代。IBM研究表明98%的对象是“朝生夕死“，不需要按照1-1的比例来划分内存空间，而是将内存分为一块较大的”Eden“空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。Hotspot虚拟机默认Eden和Survivor的比例是8-1.即每次可用整个新生代的90%, 只有一个survivor，即1/10被”浪费“。当然，98%的对象回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够时，需要依赖其他内存(老年代)进行分配担保(Handle Promotion).</p><p>如果另外一块survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p><p>Eden Space字面意思是伊甸园，对象被创建的时候首先放到这个区域，进行垃圾回收后，不能被回收的对象被放入到空的survivor区域。</p><p>Survivor Space幸存者区，用于保存在eden space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两个，分别为To Survivor、 From Survivor，这个两个区域的空间大小是一样的。执行垃圾回收的时候Eden区域不能被回收的对象被放入到空的survivor（也就是To Survivor，同时Eden区域的内存会在垃圾回收的过程中全部释放），另一个survivor（即From Survivor）里不能被回收的对象也会被放入这个survivor（即To Survivor），然后To Survivor 和 From Survivor的标记会互换，始终保证一个survivor是空的。</p><p>为啥需要两个survivor？因为需要一个完整的空间来复制过来。当满的时候晋升。每次都往标记为to的里面放，然后互换，这时from已经被清空，可以当作to了。</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>复制收集算法在对象成活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以，老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出一种”标记-整理“Mark-Compact算法，标记过程仍然和标记-清除一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理端边界以外的内存.</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前商业虚拟机的垃圾收集都采用”分代收集“(Generational Collection)算法，这种算法根据对象存活周期的不同将内存划分为几块。一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代，每次垃圾收集时都发现大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率较高，没有额外的空间对它进行分配担保，就必须使用”标记-清理“和”标记-整理“算法来进行回收。</p><h4 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h4><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法去中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li></ul><p>从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查里面的引用，必然消耗很多时间。</p><p>可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行–这里”一致性“的意思是指整个分析期间整个执行系统看起来就像被冻结在某个时间点，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程(Sun公司将这件事情称为”Stop The World“)的一个重要原因，即使是在号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也必须停顿的。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>标记-复制。</p><p>单线程，一个CPU或一条收集线程去完成垃圾收集工作，收集时必须暂停其他所有的工作线程，直到它结束。</p><p>虽然如此，它依然是虚拟机运行在Client模式下的默认新生代收集器。简单而高效。</p><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew是Serial收集器的多线程版本。Server模式下默认新生代收集器，除了Serial收集器之外，只有它能与CMS收集器配合工作。</p><p>并行 Parallel<br>指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p><p>并发 Concurrent<br>指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，用户程序再继续运行，而垃圾收集程序运行于另一个CPU上。</p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器。看上去来ParNew一样，有什么特别？</p><p>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS等收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间。而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间和CPU总小号时间的比值，即吞吐量 = 运行用户代码时间 / (运行用户代码时间+垃圾收集时间)，虚拟机总共运行了100min，其中垃圾收集花费了1min，那吞吐量就是99%.</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效地利用CPU时间，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis以及直接设置吞吐量大小的-XX:GCTimeRatio。</p><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器。给Client模式下的虚拟机使用。</p><p>新生代采用复制算法，暂停所有用户线程；</p><p>老年代采用标记-整理算法，暂停所有用户线程；</p><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>是Parallel Scavenge收集器的老年代版本，用于老年代的垃圾回收，但与Parallel Scavenge不同的是，它使用的是“标记-整理算法”。适用于注重于吞吐量及CPU资源敏感的场合。</p><p>使用方式：-XX:+UseParallelOldGC，打开该收集器后，将使用Parallel Scavenge（年轻代）+Parallel Old（老年代）的组合进行GC。</p><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类尤其重视服务的响应速度，希望系统停顿时间最短。CMS收集器就非常符合这类应用的需求。</p><p>CMS基于 标记-清除算法实现。整个过程分为4个步骤：</p><p>初始标记(CMS initial mark) -stop the world<br>并发标记(CMS concurrent mark)<br>重新标记(CMS remark) -stop the world<br>并发清除(CMS concurrent sweep)<br>初始标记，重新标记这两个步骤仍然需要Stop The World, 初始标记仅仅标记以下GC Roots能直接关联的对象，速度很快。</p><p>并发标记就是进行GC Roots Tracing的过程；</p><p>而重新标记阶段则是为了修正并发标记期间因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段停顿比初始标记稍微长，但远比并发标记的时间短。</p><p>整个过程耗时最长的并发标记和并发清除过程，收集器都可以与用户线程一起工作。总体上来说，CMS收集器的内存回收过程与用户线程一起并发执行的。</p><p>CMS特点：并发收集，低停顿。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li><p>CMS收集器对CPU资源非常敏感。默认启动的回收线程数是(CPU+3)/4. 当CPU 4个以上时，并发回收垃圾收集线程不少于25%的CPU资源。</p></li><li><p>CMS收集器无法处理浮动垃圾(Floating Garbage), 可能出现”Concurrent Mode Failure“失败而导致另一次Full GC的产生。由于CMS并发清理时，用户线程还在运行，伴随产生新垃圾，而这一部分出现在标记之后，只能下次GC时再清理。这一部分垃圾就称为”浮动垃圾“。由于CMS运行时还需要给用户空间继续运行，则不能等老年代几乎被填满再进行收集，需要预留一部分空间提供并发收集时，用户程序运行。JDK1.6中，CMS启动阈值为92%. 若预留内存不够用户使用，则出现一次Concurent Mode Failure失败。这时虚拟机启动后备预案，临时启用Serial Old收集老年代，这样停顿时间很长。</p></li><li>CMS基于”标记-清除“算法实现的，则会产生大量空间碎片，空间碎片过多时，没有连续空间分配给大对象，不得不提前触发一次FUll GC。当然可以开启-XX:+UseCMSCompactAtFullCollection(默认开)，在CMS顶不住要FullGC时开启内存碎片合并整理过程。内存整理过程是无法并发的，空间碎片问题没了，但停顿时间变长。</li></ol><h5 id="面试题：CMS一共会有几次STW"><a href="#面试题：CMS一共会有几次STW" class="headerlink" title="面试题：CMS一共会有几次STW"></a>面试题：CMS一共会有几次STW</h5><p>首先，回答两次，初始标记和重新标记需要。</p><p>然后，CMS并发的代价是预留空间给用户，预留不足的时候触发FUllGC，这时Serail Old会STW.</p><p>然后，CMS是标记-清除算法，导致空间碎片，则没有连续空间分配大对象时，FUllGC, 而FUllGC会开始碎片整理， STW.</p><p>即2次或多次。</p><h5 id="CMS什么时候FUll-GC"><a href="#CMS什么时候FUll-GC" class="headerlink" title="CMS什么时候FUll GC"></a>CMS什么时候FUll GC</h5><p>除直接调用System.gc外，触发Full GC执行的情况有如下四种。</p><h6 id="旧生代空间不足"><a href="#旧生代空间不足" class="headerlink" title="旧生代空间不足"></a>旧生代空间不足</h6><p>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：</p><p>java.lang.OutOfMemoryError: Java heap space</p><p>为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p><h6 id="Permanet-Generation空间满"><a href="#Permanet-Generation空间满" class="headerlink" title="Permanet Generation空间满"></a><del>Permanet Generation空间满</del></h6><p>PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：</p><p>java.lang.OutOfMemoryError: PermGen space</p><p>为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p><h6 id="CMS-GC时出现promotion-failed和concurrent-mode-failure"><a href="#CMS-GC时出现promotion-failed和concurrent-mode-failure" class="headerlink" title="CMS GC时出现promotion failed和concurrent mode failure"></a>CMS GC时出现promotion failed和concurrent mode failure</h6><p>对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。</p><p>promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。</p><p>应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。</p><h6 id="统计得到的Minor-GC晋升到旧生代的平均大小大于旧生代的剩余空间"><a href="#统计得到的Minor-GC晋升到旧生代的平均大小大于旧生代的剩余空间" class="headerlink" title="统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间"></a>统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</h6><p>这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。</p><p>例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。</p><p>当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。</p><p>除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p><h4 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h4><p>G1的第一篇paper（附录1）发表于2004年，在2012年才在jdk1.7u4中可用。oracle官方计划在jdk9中将G1变成默认的垃圾收集器，以替代CMS。为何oracle要极力推荐G1呢，G1有哪些优点?</p><p><strong>首先，G1的设计原则就是简单可行的性能调优</strong><br>开发人员仅仅需要声明以下参数即可：<br><code>-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200</code></p><p>其中-XX:+UseG1GC为开启G1垃圾收集器，-Xmx32g 设计堆内存的最大内存为32G，-XX:MaxGCPauseMillis=200设置GC的最大暂停时间为200ms。如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可。</p><p><strong>其次，G1将新生代，老年代的物理空间划分取消了。</strong><br>这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。<br><img src="/images/abandoneden.PNG" alt="取消新生代老年代物理空间划分"></p><p>取而代之的是，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。</p><p><img src="/images/g1mem.webp" alt="新的g1mem"></p><p>在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</p><h5 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h5><p>说起大对象的分配，我们不得不谈谈对象的分配策略。它分为3个阶段：</p><ol><li>TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区</li><li>Eden区中分配</li><li>Humongous区分配</li></ol><p>TLAB为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针。在Eden空间中，每一个线程都有一个固定的分区用于分配对象，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步。</p><p>对TLAB空间中无法分配的对象，JVM会尝试在Eden空间中进行分配。如果Eden空间无法容纳该对象，就只能在老年代中进行分配空间。</p><p>最后，G1提供了两种GC模式，Young GC和Mixed GC，两种都是Stop The World(STW)的。下面我们将分别介绍一下这2种模式。</p><p><strong>G1 Young GC</strong>:<br>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。</p><p>这时，我们需要考虑一个问题，如果仅仅GC 新生代对象，我们如何找到所有的根对象呢？ 老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。</p><p>在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。</p><p>但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。</p><p>需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。</p><p>Young GC 阶段：</p><p>阶段1：根扫描</p><p>静态和本地对象被扫描</p><p>阶段2：更新RS</p><p>处理dirty card队列更新RS</p><p>阶段3：处理RS</p><p>检测从年轻代指向年老代的对象</p><p>阶段4：对象拷贝</p><p>拷贝存活的对象到survivor/old区域</p><p>阶段5：处理引用队列</p><p>软引用，弱引用，虚引用处理</p><p><strong>G1 Mix GC</strong> ：<br>Mix GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。</p><p>它的GC步骤分2步：</p><p>1.全局并发标记（global concurrent marking）</p><p>2.拷贝存活对象（evacuation）</p><p>在进行Mix GC之前，会先进行global concurrent marking（全局并发标记）。 global concurrent marking的执行过程是怎样的呢？</p><p>在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。global concurrent marking的执行过程分为五个步骤：</p><p>初始标记（initial mark，STW）</p><p>在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。</p><p>根区域扫描（root region scan</p><p>G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。</p><p>并发标记（Concurrent Marking）</p><p>G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断</p><p>最终标记（Remark，STW）</p><p>该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理。</p><p>清除垃圾（Cleanup，STW）</p><p>在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发。</p><p>三色标记算法<br>提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。 首先，我们将对象分成三种类型的。</p><p>黑色:根对象，或者该对象与它的子对象都被扫描</p><p>灰色:对象本身被扫描,但还没扫描完该对象中的子对象</p><p>白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</p><p>当GC开始扫描对象时，按照如下图步骤进行对象的扫描：</p><p>根对象被置为黑色，子对象被置为灰色。</p><p><img src="/img/blog/post/jvm/5aabba918215f.webp" alt="三色收集器"></p><p>继续由灰色遍历,将已扫描了子对象的对象置为黑色。<br><img src="/img/blog/post/jvm/5aabba91a1ccd.webp" alt="三色收集器"></p><p>遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。</p><p><img src="/img/blog/post/jvm/5aabba91bd8c3.webp" alt="三色收集器"></p><p>这看起来很美好，但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题</p><p>我们看下面一种情况，当垃圾收集器扫描到下面情况时:<br><img src="/img/blog/post/jvm/5aabba91db437.webp" alt="三色收集器"></p><p>这时候应用程序执行了以下操作：</p><p>A.c=C<br>B.c=null<br>这样，对象的状态图变成如下情形：<br><img src="/img/blog/post/jvm/5aabba91ec8a9.webp" alt="三色收集器"></p><p>这时候垃圾收集器再标记扫描的时候就会下图成这样：</p><p><img src="/img/blog/post/jvm/5aabba92147f7.webp" alt="三色收集器"><br>很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的。那么我们如何保证应用程序在运行的时候，GC标记的对象不丢失呢？有如下2中可行的方式：</p><p>1.在插入的时候记录对象</p><p>2.在删除的时候记录对象</p><p>刚好这对应CMS和G1的2种不同实现方式：</p><p>在CMS采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。</p><p>在G1中，使用的是STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象，它有3个步骤：</p><p>1.在开始标记的时候生成一个快照图标记存活对象</p><p>2.在并发标记的时候所有被改变的对象入队（在write barrier里把所有旧的引用所指向的对象都变成非白的）</p><p>3.可能存在游离的垃圾，将在下次被收集</p><p>这样，G1到现在可以知道哪些老的分区可回收垃圾最多。 当全局并发标记完成后，在某个时刻，就开始了Mix GC。这些垃圾回收被称作“混合式”是因为他们不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区。混合式垃圾收集如下图：</p><p><img src="/img/blog/post/jvm/5aabba9242bdb.webp" alt="三色收集器"><br>混合式GC也是采用的复制的清理策略，当GC完成后，会重新释放空间。</p><p><img src="/img/blog/post/jvm/5aabba9268e24.webp" alt="三色收集器"></p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h3><p>首先，先要知道什么是类加载器。简单说，类加载器就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。如果站在JVM的角度来看，只存在两种类加载器:</p><h4 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h4><p>由C++语言实现（针对HotSpot）,负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录或<code>-Xbootclasspath</code>参数指定的路径中的类库加载到内存中。</p><h4 id="其他类加载器"><a href="#其他类加载器" class="headerlink" title="其他类加载器"></a>其他类加载器</h4><p>由Java语言实现，继承自抽象类ClassLoader。如：</p><ol><li><p>扩展类加载器（Extension ClassLoader）：负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录或<code>java.ext.dirs</code>系统变量指定的路径中的所有类库。</p></li><li><p>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p></li></ol><h3 id="为什么需要双亲委派模型？"><a href="#为什么需要双亲委派模型？" class="headerlink" title="为什么需要双亲委派模型？"></a>为什么需要双亲委派模型？</h3><p>为什么需要双亲委派模型呢？假设没有双亲委派模型，试想一个场景：</p><p><code>黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，导致“病毒代码”被执行。</code></p><p>而有了双亲委派模型，黑客自定义的java.lang.String类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的java.lang.String类，最终自定义的类加载器无法加载java.lang.String类。</p><p>或许你会想，我在自定义的类加载器里面强制加载自定义的java.lang.String类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。</p><h3 id="如何实现双亲委派模型？"><a href="#如何实现双亲委派模型？" class="headerlink" title="如何实现双亲委派模型？"></a>如何实现双亲委派模型？</h3><p>双亲委派模型的原理很简单，实现也简单。每次通过先委托父类加载器加载，当父类加载器无法加载时，再自己加载。其实ClassLoader类默认的loadClass方法已经帮我们写好了，我们无需去写。在都集中在java.lang.ClassLoader的loadClass()方法中：</p><div class="hljs"><pre><code class="hljs java">
<span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)
        <span class="hljs-keyword">throws</span> ClassNotFoundException
    &#123;
        <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;
            <span class="hljs-comment">// First, check if the class has already been loaded</span>
            Class&lt;?&gt; c = findLoadedClass(name);
            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-keyword">long</span> t0 = System.nanoTime();
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;
                        c = parent.loadClass(name, <span class="hljs-keyword">false</span>);
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        c = findBootstrapClassOrNull(name);
                    &#125;
                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
                    <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>
                    <span class="hljs-comment">// from the non-null parent class loader</span>
                &#125;

                <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-comment">// If still not found, then invoke findClass in order</span>
                    <span class="hljs-comment">// to find the class.</span>
                    <span class="hljs-keyword">long</span> t1 = System.nanoTime();
                    c = findClass(name);

                    <span class="hljs-comment">// this is the defining class loader; record the stats</span>
                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    PerfCounter.getFindClasses().increment();
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (resolve) &#123;
                resolveClass(c);
            &#125;
            <span class="hljs-keyword">return</span> c;
        &#125;
    &#125;</code></pre></div><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>从上面代码可以明显看出，loadClass(String, boolean)函数即实现了双亲委派模型！整个大致过程如下：</p><ol><li>首先，检查一下指定名称的类是否已经加载过，如果加载过了， 就不需要再加载，直接返回。</li><li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</li><li>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。</li></ol><h4 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h4><p>自定义类加载器就需要实现findClass，其默认实现如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);
&#125;</code></pre></div><p>可以看出，抽象类ClassLoader的findClass函数默认是抛出异常的。而前面我们知道，loadClass在父加载器无法加载类的时候，就会调用我们自定义的类加载器中的findeClass函数，因此我们必须要在loadClass这个函数里面实现将一个指定类名称转换为Class对象。</p><p>如果是是读取一个指定的名称的类为字节数组的话，这很好办。但是如何将字节数组转为Class对象呢？很简单，Java提供了defineClass方法，通过这个方法，就可以把一个字节数组转为Class对象啦~</p><h4 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h4><p>将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。如，假设class文件是加密过的，则需要解密后作为形参传入defineClass函数。其默认实现如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)
        <span class="hljs-keyword">throws</span> ClassFormatError  &#123;
        <span class="hljs-keyword">return</span> defineClass(name, b, off, len, <span class="hljs-keyword">null</span>);
&#125;

<span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len,
                                         ProtectionDomain protectionDomain)
        <span class="hljs-keyword">throws</span> ClassFormatError
    &#123;
        protectionDomain = preDefineClass(name, protectionDomain);
        String source = defineClassSourceLocation(protectionDomain);
        Class&lt;?&gt; c = defineClass1(<span class="hljs-keyword">this</span>, name, b, off, len, protectionDomain, source);
        postDefineClass(c, protectionDomain);
        <span class="hljs-keyword">return</span> c;
    &#125;</code></pre></div><p>下面是一个classLoader简单的实现：</p><div class="hljs"><pre><code class="hljs java"> 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span></span>
<span class="hljs-class"></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name)
    &#123;
        String myPath = <span class="hljs-string">"data"</span> + File.separator + name.replace(<span class="hljs-string">"."</span>, File.separator) + <span class="hljs-string">".class"</span>;
        System.out.println(myPath);
        <span class="hljs-keyword">byte</span>[] cLassBytes = <span class="hljs-keyword">null</span>;
        Path path = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span>
        &#123;
            path = Paths.get(<span class="hljs-keyword">new</span> URI(myPath));
            cLassBytes = Files.readAllBytes(path);
        &#125; <span class="hljs-keyword">catch</span> (IOException | URISyntaxException e)
        &#123;
            e.printStackTrace();
        &#125;
        Class clazz = defineClass(name, cLassBytes, <span class="hljs-number">0</span>, cLassBytes.length);
        <span class="hljs-keyword">return</span> clazz;
    &#125;
&#125;</code></pre></div><h2 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h2><h3 id="使用指定垃圾收集器指令"><a href="#使用指定垃圾收集器指令" class="headerlink" title="使用指定垃圾收集器指令"></a>使用指定垃圾收集器指令</h3><ol><li>开启Serial收集器的方式：<code>-XX:+UseSerialGC</code></li><li>开启Parallel收集器的方式: <code>-XX:+UseParallelGC -XX:+UseParallelOldGC</code></li><li>开启CMS收集器的方式: <code>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</code></li><li>开启G1收集器的方式: <code>-XX:+UseG1GC</code></li></ol><h3 id="jvm相关指令"><a href="#jvm相关指令" class="headerlink" title="jvm相关指令"></a>jvm相关指令</h3><ol><li>当虚拟机出现内存溢出时Dump出当前内存转储快照：<code>-XX:+HeapDumpOnOutOfMemoryError</code></li><li>指定虚拟机堆的最小内存为20m：<code>-Xms20m</code></li><li>指定虚拟机堆的最大内存为20m：<code>-Xmx20m</code></li><li><del>设置本地方法栈大小：<code>-Xoss</code></del></li><li>设置栈容量：<code>-Xss</code></li><li><del>设置永久代大小：<code>-XX:PermSize=10M</code> <code>-XX:MaxPermSize=10M</code></del></li><li>设置本机直接内存（DirectMemory）：<code>-XX：MaxDirectMemorySize</code></li></ol><h3 id="MaxGCPauseMillis调优"><a href="#MaxGCPauseMillis调优" class="headerlink" title="MaxGCPauseMillis调优"></a>MaxGCPauseMillis调优</h3><p><code>-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200</code></p><p>该指令设置了最大内存和最大暂停时间，主要平衡长时间暂停还是吞吐量降低的问题。理论暂时时间长，吞吐量较大。暂停时间短可能导致频繁gc。</p><h3 id="其他调优参数"><a href="#其他调优参数" class="headerlink" title="其他调优参数"></a>其他调优参数</h3><p><code>-XX:G1HeapRegionSize=n</code></p><p>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p><p><code>-XX:ParallelGCThreads=n</code></p><p>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。</p><p>如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 的值可以是逻辑处理器数的 5/16 左右。</p><p><code>-XX:ConcGCThreads=n</code></p><p>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。</p><p><code>-XX:InitiatingHeapOccupancyPercent=45</code></p><p>设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。</p><p>避免使用以下参数：</p><p>避免使用 <code>-Xmn</code> 选项或 <code>-XX:NewRatio</code>等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。</p><h3 id="触发Full-GC"><a href="#触发Full-GC" class="headerlink" title="触发Full GC"></a>触发Full GC</h3><p>在某些情况下，G1触发了Full GC，这时G1会退化使用Serial收集器来完成垃圾的清理工作，它仅仅使用单线程来完成GC工作，GC暂停时间将达到秒级别的。整个应用处于假死状态，不能处理任何请求，我们的程序当然不希望看到这些。那么发生Full GC的情况有哪些呢？</p><h4 id="并发模式失败"><a href="#并发模式失败" class="headerlink" title="并发模式失败"></a>并发模式失败</h4><p>G1启动标记周期，但在Mix GC之前，老年代就被填满，这时候G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数<code>-XX:ConcGCThreads</code>等）。</p><h4 id="晋升失败或者疏散失败"><a href="#晋升失败或者疏散失败" class="headerlink" title="晋升失败或者疏散失败"></a>晋升失败或者疏散失败</h4><p>G1在进行GC的时候没有足够的内存供存活对象或晋升对象使用，由此触发了Full GC。可以在日志中看到(to-space exhausted)或者（to-space overflow）。解决这种问题的方式是：</p><ul><li><p>增加 <code>-XX:G1ReservePercent</code> 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量。</p></li><li><p>通过减少<code>-XX:InitiatingHeapOccupancyPercent</code> 提前启动标记周期。</p></li><li><p>也可以通过增加 <code>-XX:ConcGCThreads</code> 选项的值来增加并行标记线程的数目。</p></li></ul><h4 id="巨型对象分配失败"><a href="#巨型对象分配失败" class="headerlink" title="巨型对象分配失败"></a>巨型对象分配失败</h4><p>当巨型对象找不到合适的空间进行分配时，就会启动Full GC，来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大-XX:G1HeapRegionSize，使巨型对象不再是巨型对象。</p></article><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/jvm/">jvm</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/java/">java</a> <a class="hover-with-bg" href="/tags/jvm/">jvm</a> <a class="hover-with-bg" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用: <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际协议</a>，转载请保留原文链接及作者。</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/post/5227f27b.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">租房扫盲贴以及我为什么不租品牌公寓</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"><a href="/post/749ad7d8.html"><span class="hidden-mobile">docker常用命令</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></div></div></div><div class="comments" id="comments"><div id="vcomments"></div><script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="/js/Valine.min.js"></script><script type="text/javascript">var notify=!1,verify=!1,oldLoadVa=window.onload;window.onload=function(){oldLoadVa&&oldLoadVa(),new Valine({lang:"zh-cn",el:"#vcomments",notify:notify,verify:verify,app_id:"dXhxgFWthuLPDnYYuAJbIe6X-MdYXbMMI",app_key:"In8P9esI1pt8dBUc7JbFCvLa",placeholder:"说点什么",avatar:"/retro",meta:["nick","mail","link"],pageSize:"10",emoticon_url:"/emoji",emoticon_list:["动耳朵.gif","抖脚脚.gif","抖眼.gif","抖眼镜.gif","风吹秀发.gif","慌张.gif","夹住.gif","开车.gif","哭唧唧.gif","绿色的.gif","跳舞.gif","跳着走.gif","小花花.gif","眼睛转.gif","摇头.gif","眨眼.gif","吃东西.gif","弹肚皮.gif","动次打次.gif","比心心.gif","吹风.gif","打篮球.gif","都是小心心.gif","吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"]})}</script></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-md"><div class="container custom post-content mx-auto"><img src="/images/wechatpay.webp" class="rounded mx-auto d-block mt-5" style="width:120px;height:150px;vertical-align:-webkit-baseline-middle"><br><div style="text-align:center">买个卤蛋，吃根冰棒</div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><svg t="1586793095516" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3553" width="16" height="16"><path d="M512 0c282.7776 0 512 229.2224 512 512s-229.2224 512-512 512S0 794.7776 0 512 229.2224 0 512 0z m0 71.424a440.576 440.576 0 1 0 0 881.152 440.576 440.576 0 0 0 0-881.152z m8.192 166.7072c55.296 0 108.3904 15.5136 153.7536 44.2368a35.7376 35.7376 0 0 1-38.144 60.3648 215.6032 215.6032 0 0 0-115.5584-33.1264c-116.6336 0-210.6368 90.88-210.6368 202.3936s94.0032 202.3936 210.6368 202.3936c41.0112 0 80.2304-11.264 113.8688-32.1024a35.7376 35.7376 0 0 1 37.632 60.7744 287.1296 287.1296 0 0 1-151.552 42.8032c-155.4944 0-282.0608-122.368-282.0608-273.8688 0-151.552 126.5664-273.8688 282.112-273.8688z" fill="#8a8a8a" p-id="3554"></path></svg> <span itemprop="copyrightYear" id="cori">2021</span><br><svg t="1584375698087" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1913" width="23" height="14"><path d="M513.984496 513.984496c141.383442 0 256-114.616558 256-256S655.367938 1.984496 513.984496 1.984496 257.984496 116.601054 257.984496 257.984496s114.616558 256 256 256z m0-59.534884c-108.50431 0-196.465116-87.960806-196.465116-196.465116s87.960806-196.465116 196.465116-196.465116 196.465116 87.960806 196.465116 196.465116-87.960806 196.465116-196.465116 196.465116z" fill="#8a8a8a" p-id="1914"></path><path d="M1020.031008 992.248062c0-281.647628-227.423256-510.015504-508.031008-510.015504S3.968992 710.600434 3.968992 992.248062a29.767442 29.767442 0 1 0 59.534884 0c0-248.820093 200.827039-450.48062 448.496124-450.48062s448.496124 201.660527 448.496124 450.48062a29.767442 29.767442 0 1 0 59.534884 0z" fill="#8a8a8a" p-id="1915"></path></svg> <span class="author" id="cori" itemprop="copyrightHolder">Bryce Huang</span></div></div><script type="text/javascript" src="/js/commentTyping.min.js"></script></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:6,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="/js/custom.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","JVM学习笔记&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>