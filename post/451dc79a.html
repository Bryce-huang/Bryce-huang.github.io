<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/blog/crown.png"><link rel="icon" type="image/png" href="/img/blog/crown.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="description" content="Nothing is so common as the wish to be remarkables"><meta name="author" content="Bryce Huang"><meta name="keywords" content="blog,program,life"><title>mysql基础知识 - Bryce&#39;s Club</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/dracula.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css"><link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bryce's Club" type="application/atom+xml"></head><body><div id="dark" onclick="switchDarkMode()"></div><script>var isNight=18<=(new Date).getHours()||(new Date).getHours()<8;(matchMedia("(prefers-color-scheme: dark)").matches||isNight||"1"===localStorage.getItem("dark"))&&(isNight&&"1"===localStorage.getItem("noDark")||document.body.classList.add("dark")),document.getElementById("dark").innerHTML=document.querySelector("body").classList.contains("dark")?"🌙":"🌞"</script><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>Bryce's Club</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item"><a class="nav-link" href="/messageboard/"><i class="iconfont icon-speakernotes"></i> 留言</a></li><li class="nav-item"><a class="nav-link" href="/features/"><i class="iconfont icon-exp-fill"></i> 功能</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/img/star-guardian/champion-pajama-group-splash.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><div class="mt-3 post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-07-18 23:26">星期六, 七月 18日 2020, 11:26 晚上</time></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 12.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 132 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><div class="post-content mx-auto" id="post"><article class="markdown-body"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><div class="hljs"><pre><code class="hljs shell">docker run -p 3306:3306 --name mysql -v /data/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</code></pre></div><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="设计范式"><a href="#设计范式" class="headerlink" title="设计范式"></a>设计范式</h3><h4 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h4><p>强调的是列的原子性，即列不能够再分成其他几列。 无重复列。</p><p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。</p><h4 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h4><p>首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。</p><h4 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h4><p>在1NF基础上，任何非主属性不依赖于其它非主属性[在2NF基础上消除传递依赖]。</p><p>第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="FULLTEXT"><a href="#FULLTEXT" class="headerlink" title="FULLTEXT"></a>FULLTEXT</h4><p>即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE INDEX创建FULLTEXT索引，要比先为一张表建立FULLTEXT然后再将数据写入的速度快很多。</p><p>全文索引的使用方法并不复杂：</p><p>创建：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-string">`FULLINDEX`</span> <span class="hljs-keyword">USING</span> FULLTEXT(<span class="hljs-string">`cname1`</span>[,cname2…]);`</code></pre></div><p>查找：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(cname1[,cname2…]) AGAINST (<span class="hljs-string">'word'</span> <span class="hljs-keyword">MODE</span> );</code></pre></div><p>其中， MODE为搜寻方式（IN BOOLEAN MODE ，IN NATURAL LANGUAGE MODE ，IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION / WITH QUERY EXPANSION）</p><h4 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h4><p>由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。</p><p>HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</p><ol><li>Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</li><li>Hash 索引无法被用来避免数据的排序操作。由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</li><li>Hash 索引不能利用部分索引键查询。对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</li><li>Hash 索引在任何时候都不能避免表扫描。前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</li><li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。</li></ol><p>hash值即为通过特定算法由指定列数据计算出来，磁盘地址即为所在数据行存储在硬盘上的地址（也有可能是其他存储地址，其实MEMORY会将hash表导入内存。<br>这样，当我们进行WHERE age = 18 时，<em>会将18通过相同的算法计算出一个hash值==&gt;在hash表中找到对应的储存地址==&gt;根据存储地址取得数据</em>。<br>所以，每次查询时都要遍历hash表，直到找到对应的hash值，如（4），数据量大了之后，hash表也会变得庞大起来，性能下降，遍历耗时增加，如（5）。</p><h4 id="BTREE"><a href="#BTREE" class="headerlink" title="BTREE"></a>BTREE</h4><p>BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中.<br>BTREE在MyISAM里的形式和Innodb稍有不同</p><p>在 Innodb里，有两种形态：一是primary key形态，其leaf node里存放的是数据，而且不仅存放了索引键的数据，还存放了其他字段的数据。二是secondary index，其leaf node和普通的BTREE差不多，只是还存放了指向主键的信息.</p><p>而在MyISAM里，主键和其他的并没有太大区别。不过和Innodb不太一样的地方是在MyISAM里，leaf node里存放的不是主键的信息，而是指向数据文件里的对应数据行的信息</p><h4 id="RTREE"><a href="#RTREE" class="headerlink" title="RTREE"></a>RTREE</h4><p>RTREE在mysql很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。</p><p>相对于BTREE，RTREE的优势在于范围查找.</p><h4 id="各种索引的使用情况"><a href="#各种索引的使用情况" class="headerlink" title="各种索引的使用情况"></a>各种索引的使用情况</h4><ol><li>对于BTREE这种Mysql默认的索引类型，具有普遍的适用性</li><li>由于FULLTEXT对中文支持不是很好，在没有插件的情况下，最好不要使用。</li><li>对于一些搜索引擎级别的应用来说，FULLTEXT同样不是一个好的处理方法，Mysql的全文索引建立的文件还是比较大的，而且效率不是很高，即便是使用了中文分词插件，对中文分词支持也只是一般。真要碰到这种问题，Apache的Lucene或许是你的选择</li><li>正是因为hash表在处理较小数据量时具有无可比拟的素的优势，所以hash索引很适合做缓存（内存数据库）。如mysql数据库的内存版本Memsql，使用量很广泛的缓存工具Mencached，NoSql数据库redis等，都使用了hash索引这种形式。当然，不想学习这些东西的话Mysql的MEMORY引擎也是可以满足这种需求的。</li></ol><h3 id="索引种类"><a href="#索引种类" class="headerlink" title="索引种类"></a>索引种类</h3><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>主键是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键：<code>alert table tablename add primary key (&#39;字段名&#39;)</code></p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>索引列的所有值都只能出现一次，即必须唯一，值可以为空: <code>alter table table_name add primary key (字段名&#39;);</code></p><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>基本的索引类型，值可以为空，没有唯一性的限制: <code>alter table table_name add index (&#39;字段名&#39;);</code></p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引的索引类型为FULLTEXT。全文索引可以在varchar、char、text类型的列上创建。可以通过ALTER TABLE或CREATE INDEX命令创建。对于大规模的数据集，通过ALTER TABLE（或者CREATE INDEX）命令创建全文索引要比把记录插入带有全文索引的空表更快。MyISAM支持全文索引，InnoDB在mysql5.6之后支持了全文索引。全文索引不支持中文需要借sphinx(coreseek)或迅搜&lt;、code&gt;技术处理中文。</p><p>用法：<code>alter table 表名 add FULLTEXT(&#39;字段名&#39;);</code></p><h4 id="索引总结"><a href="#索引总结" class="headerlink" title="索引总结"></a>索引总结</h4><p><strong>优点:</strong></p><p>传统的查询方法，是按照表的顺序遍历的，不论查询几条数据，mysql需要将表的数据从头到尾遍历一遍,在我们添加完索引之后，mysql一般通过BTREE算法生成一个索引文件，在查询数据库时，找到索引文件进行遍历(折半查找大幅查询效率)，找到相应的键从而获取数据</p><p><strong>缺点:</strong></p><ol><li>创建索引是为产生索引文件的，占用磁盘空间</li><li>索引文件是一个二叉树类型的文件，可想而知我们的dml操作同样也会对索引文件进行修改，所以性能会下降</li></ol><p><strong>在哪些column上使用索引?</strong></p><ol><li>较频繁的作为查询条件字段应该创建索引</li><li>唯一性太差的字段不适合创建索引，尽管频繁作为查询条件，例如gender性别字段</li><li>更新非常频繁的字段不适合作为索引</li><li>不会出现在where子句中的字段不该创建索引</li></ol><p><em>总结：</em><br>a: 肯定在where条经常使用 b: 该字段的内容不是唯一的几个值 c: 字段内容不是频繁变化。</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>MySQL数据库备份分为逻辑备份和物理备份两大类，犹豫到底用那种备份方式的时候先了解下它们的差异：<br>逻辑备份的特点是：直接生成SQL语句，在恢复的时候执行备份的SQL语句实现数据库数据的重现。</p><p>物理备份的特点是：拷贝相关数据文件。</p><p>这二种备份差异：逻辑备份其备份、还原慢，但备份文件占用的空间小；物理备份其备份还原快，备份文件占用空间大。</p><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>逻辑备份成sql语句<br>mysqldump的大致实现过程是：连接 -&gt; 初始化信息 -&gt; 刷新表（锁表）-&gt; 记录偏移量 -&gt; 开启事务（一致性快照）-&gt; 记录偏移量 -&gt; 解锁表，因为开启了一致性读，可以得到innodb的一致性，又因为解锁表了，MyISAM表一致性得不到保证，所以尽量别使用MyISAM表。</p><div class="hljs"><pre><code class="hljs sql">mysqldump -uroot -p123 <span class="hljs-comment">--default-character-set=utf8 --single-transaction --master-data=1 -R -E --triggers -B dba_test dba_test2 &gt; /home/dxy/dba_test.sql</span></code></pre></div><p>详细参考：<a href="https://www.cnblogs.com/zhoujinyi/p/5789465.html" target="_blank" rel="noopener">mysqldump</a></p><h3 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h3><p>物理备份</p><div class="hljs"><pre><code class="hljs sql">xtrabackup <span class="hljs-comment">--user=root --password=123 --datadir=/var/lib/mysql/ --backup --no-timestamp --slave-info --safe-slave-backup --parallel=5 --databases='xtra_test dba_test' --target-dir=/home/bryce/xtrabackup/</span></code></pre></div><p>还原</p><div class="hljs"><pre><code class="hljs sql">xtrabackup <span class="hljs-comment">--prepare --target-dir=/home/bryce/xtrabackup/</span></code></pre></div><p>详情参考：<a href="https://www.cnblogs.com/zhoujinyi/p/5893333.html" target="_blank" rel="noopener">xtrabackup</a></p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制方法，通常由数据库管理系统用来提供对数据库的并发访问，并以编程语言来实现事务存储。</p><p>就是 同一份数据临时保留多版本的一种方式，进而实现并发控制。</p><p>如果有人从数据库中读数据的同时，有另外的人写入数据，有可能读数据的人会看到『半写』或者不一致的数据。有很多种方法来解决这个问题，叫做并发控制方法。最简单的方法，通过加锁，让所有的读者等待写者工作完成，但是这样效率会很差。MVCC 使用了一种不同的手段，每个连接到数据库的读者，在某个瞬间看到的是数据库的一个快照，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的。</p><p>当一个 MVCC 数据库需要更一个一条数据记录的时候，它不会直接用新数据覆盖旧数据，而是将旧数据标记为过时（obsolete）并在别处增加新版本的数据。这样就会有存储多个版本的数据，但是只有一个是最新的。这种方式允许读者读取在他读之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。<strong>这种多版本的方式避免了填充删除操作在内存和磁盘存储结构造成的空洞的开销，但是需要系统周期性整理（sweep through）以真实删除老的、过时的数据</strong>。对于面向文档的数据库（Document-oriented database，也即半结构化数据库）来说，这种方式允许系统将整个文档写到磁盘的一块连续区域上，当需要更新的时候，直接重写一个版本，而不是对文档的某些比特位、分片切除，或者维护一个链式的、非连续的数据库结构。</p><p>MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用时间戳或者事务 ID去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般我们认为MVCC有下面几个特点：</p><ol><li><p>每行数据都存在一个版本，每次数据更新时都更新该版本</p><ul><li>修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰</li><li>保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)</li><li>就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道, 因为这看来正是，在提交的时候才能知道到底能否提交成功</li></ul></li><li><p>而InnoDB实现MVCC的方式是:</p><ul><li>事务以排他锁的形式修改原始数据</li><li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li><li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li></ul></li><li><p>二者最本质的区别是: 当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？</p><ul><li>Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, undo log 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。</li><li>比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 第一类更新丢失 的情况。</li><li>也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。</li></ul></li></ol><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>MySQL中有六种日志文件，<br>分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。<br>其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系，这三种日志，对理解MySQL中的事务操作有着重要的意义。</p><h3 id="重做日志（redo-log）"><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a>重做日志（redo log）</h3><p><strong>作用：</strong></p><ul><li><p>确保事务的持久性</p></li><li><p>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p></li></ul><p><strong>内容：</strong></p><p>物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file 的物理文件中去的。</p><p><strong>什么时候产生：</strong></p><p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</p><p><strong>什么时候释放：</strong></p><p>当对应的事务脏页写入到磁盘之后，redo log 的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p><p><strong>对应的物理文件：</strong></p><p>默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfule2</p><p>innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。<br>innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2</p><p>关于文件的大小和数量，由一下两个参数配置</p><ul><li><p>innodb_log_file_size 重做日志文件的大小。</p></li><li><p>innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1</p></li></ul><p><strong>其他：</strong></p><p>很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M,Innodb存储引擎先将重做日志写入innodb_log_buffer中。</p><p>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘</p><ol><li>Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。</li><li>每个事务提交时会将重做日志刷新到重做日志文件。</li><li>当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件</li></ol><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'innodb_log_buffer_size'</span>;</code></pre></div><p>由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。</p><p>另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：</p><p>即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。<br>这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。</p><h3 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h3><p><strong>作用：</strong></p><p>保存了事务发生的之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p><p><strong>内容：</strong></p><p>逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。</p><p><strong>什么时候产生：</strong></p><p>事务开始之前，将当前的版本生成undo log，undo也会产生redo 来保证undo log 的可靠性。</p><p><strong>什么时候释放：</strong></p><p>当事务提交之后，undo log 并不能立马被删除，而是放入待清理的链表，有purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p><p><strong>对应的物理文件：</strong></p><p>MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。<br>MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数<br>如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。<br>关于MySQL5.7之后的独立undo 表空间配置参数如下</p><ul><li>innodb_undo_directory = /data/undospace/ –undo独立表空间的存放目录</li><li>innodb_undo_logs = 128 –回滚段为128KB</li><li>innodb_undo_tablespaces = 4 –指定有4个undo log文件</li></ul><p>如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%innodb_data_file_path%'</span>;</code></pre></div><p><strong>其他：</strong></p><p>undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redolog的产生。<br>默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。<br>因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。<br>因此，mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。</p><h3 id="二进制日志（binlog）"><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h3><p><strong>作用：</strong></p><ol><li>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。</li><li>用于数据库的基于时间点的还原。</li></ol><p><strong>内容：</strong></p><p>逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句<br>但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。<br>因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。</p><p><strong>什么时候产生：</strong></p><p>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</p><p>这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。</p><p>因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。</p><p>这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</p><p><strong>什么时候释放：</strong></p><p>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%expire_logs_days%'</span>;</code></pre></div><p><strong>对应物理文件：</strong></p><p>配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。</p><p>对于每个binlog日志文件，通过一个统一的index文件来组织。</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%log_bin_basename%'</span>;</code></pre></div><p><strong>其他：</strong></p><p>二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同</p><ol><li><p>作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。</p></li><li><p>内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</p></li><li><p>另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</p></li><li><p>恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog</p></li></ol><h4 id="binlog的三种模式"><a href="#binlog的三种模式" class="headerlink" title="binlog的三种模式"></a>binlog的三种模式</h4><h5 id="Statement模式"><a href="#Statement模式" class="headerlink" title="Statement模式"></a>Statement模式</h5><p>每一条修改数据的SQL都会记录到master的binlog中，slave在复制的时候，sql进程会解析成和原来在master端执行时相同的sql再执行。</p><p><strong>优点：</strong> 在 statement 模式下首先就是解决了 row 模式的缺点，不需要记录每一行数据的变化，从而减少了 binlog 的日志量，节省了 I/O 以及存储资源，提高性能。因为它只需要记录在 master 上执行的语句的细节以及执行语句的上下文信息。</p><p><strong>缺点：</strong> 在 statement 模式下，由于它是记录的执行语句，所以，为了让这些语句在 slave 端也能正确执行，那么它还必须记录每条语句在执行的时候的一些相关信息，即上下文信息，以保证所有语句在 slave 端和在 master 端执行结果相同。另外就是，由于 MySQL 现在发展比较快，很多新功能不断的加入，使 MySQL 的复制遇到了不小的挑战，自然复制的时候涉及到越复杂的内容，bug 也就越容易出现。在statement 中，目前已经发现不少情况会造成 MySQL 的复制出现问题，主要是在修改数据的时候使用了某些特定的函数或者功能才会出现，比如：sleep() 函数在有些版本中就不能被正确复制，在存储过程中使用了 last_insert_id() 函数，可能会使 slave 和 master 上得到不一致的 id 等等。由于 row 模式是基于每一行来记录变化的，所以不会出现类似的问题。</p><h5 id="Row模式"><a href="#Row模式" class="headerlink" title="Row模式"></a>Row模式</h5><p>日志中会记录每一行数据被修改的形式，然后在slave端再对相同的数据进行修改。row模式只记录要修改的数据，只有value，不会有sql多表关联的情况。</p><p><strong>优点：</strong> 在 row 模式下，binlog 中可以不记录执行的 sql 语句的上下文相关的信息，仅仅只需要记录哪一条记录被修改了，修改成什么样了，所以 row 的日志内容会非常清楚的记录下每一行数据的修改细节，非常容易理解。而且不会出现某些特定情况下的存储过程和 function，以及 trigger 的调用和触发无法被正确复制问题。<br><strong>缺点：</strong> 在 row 模式下，当所有执行语句记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。</p><h5 id="Mixed模式"><a href="#Mixed模式" class="headerlink" title="Mixed模式"></a>Mixed模式</h5><p>从官方文档中看到，之前的 MySQL 一直都只有基于 statement 的复制模式，直到 5.1.5 版本的 MySQL 才开始支持 row 复制。从 5.0 开始，MySQL 的复制已经解决了大量老版本中出现的无法正确复制的问题。但是由于存储过程的出现，给 MySQL Replication 又带来了更大的新挑战。另外，看到官方文档说，从 5.1.8 版本开始，MySQL 提供了除 Statement 和 Row 之外的第三种复制模式：Mixed，实际上就是前两种模式的结合。在 Mixed 模式下，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选择一种。新版本中的 statment 还是和以前一样，仅仅记录执行的语句。而新版本的 MySQL 也对 row 模式做了优化，并不是所有的修改都会以 row 模式来记录，比如遇到表结构变更的时候就会以 statement 模式来记录，如果 SQL 语句确实就是 update 或者 delete 等修改数据的语句，那么还是会记录所有行的变更。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySql的核心就是插件式存储引擎。</p><p>查看引擎：</p><div class="hljs"><pre><code class="hljs sql">
<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">ENGINES</span></code></pre></div><p>查看默认引擎：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'storage_engine'</span>;</code></pre></div><h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。</p><p>InnoDB是默认的MySQL引擎。</p><p>InnoDB 主要特点：</p><ol><li><p>为MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</p></li><li><p>InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上</p></li><li><p>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</p></li><li><p>InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的</p></li></ol><p>使用 InnoDB存储引擎 MySQL将在数据目录下创建一个名为 ibdata1 的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件</p><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。<br>第一个重大区别是InnoDB的数据文件本身就是索引文件。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p>叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身 要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列 作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域.</p><p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。<br>了 解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为 主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为 InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用 自增字段作为主键则是一个很好的选择。</p><h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><p>MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事物。</p><p>MyISAM主要特性：</p><ol><li>被大文件系统和操作系统支持</li><li>当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成</li><li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li><li>最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上</li><li>BLOB和TEXT列可以被索引</li><li>NULL被允许在索引的列中，这个值占每个键的0~1个字节</li><li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</li><li>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更 新比InnoDB类型的AUTO_INCREMENT更快</li><li>可以把数据文件和索引文件放在不同目录</li><li>每个字符列可以有不同的字符集</li><li>有VARCHAR的表可以固定或动态记录长度</li><li>VARCHAR和CHAR列可以多达64KB</li></ol><p>使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）</p><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。</p><p>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</p><p>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。<br>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h3 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h3><p>MEMORY存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。</p><p>MEMORY主要特性：</p><ul><li>MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度</li><li>MEMORY存储引擎执行HASH和BTREE缩影</li><li>可以在一个MEMORY表中有非唯一键值</li><li>MEMORY表使用一个固定的记录长度格式</li><li>MEMORY不支持BLOB或TEXT列</li><li>MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引</li><li>MEMORY表在所有客户端之间共享（就像其他任何非TEMPORARY表）</li><li>MEMORY表内存被存储在内存中，内存是MEMORY表和服务器在查询处理时的空闲中，创建的内部表共享</li><li>当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（使用DROP TABLE）</li></ul><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。但建议选择使用InnoDB</p><p>InnoDB 和 MyISAM之间的区别：</p><ul><li>InnoDB支持事物，而MyISAM不支持事物</li><li>InnoDB支持行级锁，而MyISAM支持表级锁</li><li>InnoDB支持MVCC, 而MyISAM不支持</li><li>InnoDB支持外键，而MyISAM不支持</li></ul><p>存储引擎对比：</p><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th><th>MEMORY</th></tr></thead><tbody><tr><td>事务安全</td><td>支持</td><td>无</td><td>无</td></tr><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>使用空间</td><td>高</td><td>低</td><td>低</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>高</td></tr><tr><td>插入数据速度</td><td>慢</td><td>快</td><td>快</td></tr><tr><td>对外键的支持</td><td>支持</td><td>无</td><td>无</td></tr></tbody></table><p>InnoDB： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p><p>MyISAM： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</p><p>MEMORY： 所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p><p>注意：同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</p><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><h3 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h3><h4 id="建立合适的索引"><a href="#建立合适的索引" class="headerlink" title="建立合适的索引"></a>建立合适的索引</h4><p>一个最重要的原则是最左前缀原理，在提这个之前要先说下联合索引，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列。另外，单列索引可以看成联合索引元素数为1的特例。</p><p>索引匹配的最左原则具体是说，假如索引列分别为A，B，C，顺序也是A，B，C：</p><ul><li>那么查询的时候，如果查询【A】【A，B】 【A，B，C】，那么可以通过索引查询</li><li>如果查询的时候，采用【A，C】，那么C这个虽然是索引，但是由于中间缺失了B，因此C这个索引是用不到的，只能用到A索引</li><li>如果查询的时候，采用【B】 【B，C】 【C】，由于没有用到第一列索引，不是最左前缀，那么后面的索引也是用不到了</li><li>如果查询的时候，采用范围查询，并且是最左前缀，也就是第一列索引，那么可以用到索引，但是范围后面的列无法用到索引</li></ul><p>因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好</p><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p><h4 id="建立索引的常用技巧"><a href="#建立索引的常用技巧" class="headerlink" title="建立索引的常用技巧"></a>建立索引的常用技巧</h4><ol><li><p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p></li><li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p></li><li><p>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</p></li><li><p>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</p></li><li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可，当然要考虑原有数据和线上使用情况</p></li></ol><h4 id="调优方法-流程"><a href="#调优方法-流程" class="headerlink" title="调优方法/流程"></a>调优方法/流程</h4><p>一般要进行SQL调优，那么就说有慢查询的SQL，系统或者server可以开启慢查询日志，尤其是线上系统，一般都会开启慢查询日志，如果有慢查询，可以通过日志来过滤。但是知道了有需要优化的SQL后，下面要做的就是如何进行调优</p><ol><li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li><li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li><li>explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li><li>order by limit 形式的sql语句让排序的表优先查</li><li>了解业务方使用场景</li><li>加索引时参照建索引的几大原则</li><li>观察结果，不符合预期继续从0分析</li></ol><h4 id="执行计划explain"><a href="#执行计划explain" class="headerlink" title="执行计划explain"></a>执行计划explain</h4><p>在日常工作中，我们有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。</p><p>使用explain 只需要在原有select 基础上加上explain关键字就可以了，如下：</p><div class="hljs"><pre><code class="hljs sql">mysql&gt; explain select * from servers;
+<span class="hljs-comment">----+-------------+---------+------+---------------+------+---------+------+------+-------+</span>
| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows | Extra |
+<span class="hljs-comment">----+-------------+---------+------+---------------+------+---------+------+------+-------+</span>
|  1 | SIMPLE      | servers | ALL  | NULL          | NULL | NULL    | NULL |    1 | NULL  |
+<span class="hljs-comment">----+-------------+---------+------+---------------+------+---------+------+------+-------+</span>
1 row in <span class="hljs-keyword">set</span> (<span class="hljs-number">0.03</span> sec)</code></pre></div><p>简要解释下explain各个字段的含义</p><p>id : 表示SQL执行的顺序的标识,SQL从大到小的执行<br>select_type：表示查询中每个select子句的类型<br>table：显示这一行的数据是关于哪张表的，有时不是真实的表名字<br>type：表示MySQL在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）<br>possible_keys：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用<br>Key：key列显示MySQL实际决定使用的键（索引），如果没有选择索引，键是NULL。<br>key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）<br>ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值<br>rows： 表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数，理论上行数越少，查询性能越好<br>Extra：该列包含MySQL解决查询的详细信息<br>EXPLAIN的特性</p><p>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况<br>EXPLAIN不考虑各种Cache<br>EXPLAIN不能显示MySQL在执行查询时所作的优化工作<br>部分统计信息是估算的，并非精确值<br>EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</p><h3 id="主机调优"><a href="#主机调优" class="headerlink" title="主机调优"></a>主机调优</h3><p>内存选择cpu的4倍，磁盘选择ssd,关闭内存交换Swap。</p><h3 id="服务调优"><a href="#服务调优" class="headerlink" title="服务调优"></a>服务调优</h3><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>explain的输出结果Extra字段为Using index时，能够触发索引覆盖。</p><h4 id="什么是回表"><a href="#什么是回表" class="headerlink" title="什么是回表"></a>什么是回表</h4><p>先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。需要遍历两次索引。</p><p>通过建立联合索引可以避免回表，主要是常用的查询字段，否则带来负面插入降低。</p><h4 id="覆盖索引解决场景"><a href="#覆盖索引解决场景" class="headerlink" title="覆盖索引解决场景"></a>覆盖索引解决场景</h4><ol><li>全表count()优化，如count(name);</li><li>列表查询回表优化，通过联合索引，将需要查询的字段建立索引。即可以查询出对应的字段</li><li>分页面查询,将order by升级为联合索引</li></ol><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li><p>innodb_buffer_pool_size： 这是安装完InnoDB后第一个应该设置的选项。缓冲池是数据和索引缓存的地方：这个值越大越好，这能保证你在大多数的读取操作时使用的是内存而不是硬盘。典型的值是5-6GB(8GB内存)，20-25GB(32GB内存)，100-120GB(128GB内存)。</p></li><li><p>innodb_log_file_size：这是redo日志的大小。redo日志被用于确保写操作快速而可靠并且在崩溃时恢复。一直到MySQL 5.1，它都难于调整，因为一方面你想让它更大来提高性能，另一方面你想让它更小来使得崩溃后更快恢复。幸运的是从MySQL 5.5之后，崩溃恢复的性能的到了很大提升，这样你就可以同时拥有较高的写入性能和崩溃恢复性能了。一直到MySQL 5.5，redo日志的总尺寸被限定在4GB(默认可以有2个log文件)。这在MySQL 5.6里被提高了。如果你知道你的应用程序需要频繁的写入数据并且你使用的时MySQL 5.6，你可以一开始就把它这是成4G。</p></li><li><p>max_connections：如果你经常看到‘Too many connections’错误，是因为max_connections的值太低了。这非常常见因为应用程序没有正确的关闭数据库连接，你需要比默认的151连接数更大的值。max_connection值被设高了(例如1000或更高)之后一个主要缺陷是当服务器运行1000个或更高的活动事务时会变的没有响应。在应用程序里使用连接池或者在MySQL里使用进程池有助于解决这一问题。</p></li></ul><p>innodb参数优化</p><div class="hljs"><pre><code class="hljs ini">default-storage-engine
innodb_buffer_pool_size       # 没有固定大小，50%测试值，看看情况再微调。但是尽量设置不要超过物理内存70%
<span class="hljs-attr">innodb_file_per_table</span>=(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)
<span class="hljs-attr">innodb_flush_log_at_trx_commit</span>=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 1是最安全的，0是性能***，2折中</span>
binlog_sync
<span class="hljs-attr">Innodb_flush_method</span>=(O_DIRECT, fdatasync)
innodb_log_buffer_size        # 100M以下
innodb_log_file_size          # 100M 以下
innodb_log_files_in_group     # 5个成员以下,一般2-3个够用（iblogfile0-N）
innodb_max_dirty_pages_pct   # 达到百分之75的时候刷写 内存脏页到磁盘。
log_bin
max_binlog_cache_size         # 可以不设置
max_binlog_size               # 可以不设置
innodb_additional_mem_pool_size    #小于2G内存的机器，推荐值是20M。32G内存以上100M</code></pre></div></article><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/database/">database</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/mysql/">mysql</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用: <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际协议</a>，转载请保留原文链接及作者。</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/post/acd7e382.html"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">使用operator-sdk自定义k8s operator</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"><a href="/post/66cb4f6f.html"><span class="hidden-mobile">Ansible简明指北</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></div></div></div><div class="comments" id="comments"><div id="vcomments"></div><script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="/js/Valine.min.js"></script><script type="text/javascript">var notify=!1,verify=!1,oldLoadVa=window.onload;window.onload=function(){oldLoadVa&&oldLoadVa(),new Valine({lang:"zh-cn",el:"#vcomments",notify:notify,verify:verify,app_id:"dXhxgFWthuLPDnYYuAJbIe6X-MdYXbMMI",app_key:"In8P9esI1pt8dBUc7JbFCvLa",placeholder:"说点什么",avatar:"/retro",meta:["nick","mail","link"],pageSize:"10",emoticon_url:"/emoji",emoticon_list:["动耳朵.gif","抖脚脚.gif","抖眼.gif","抖眼镜.gif","风吹秀发.gif","慌张.gif","夹住.gif","开车.gif","哭唧唧.gif","绿色的.gif","跳舞.gif","跳着走.gif","小花花.gif","眼睛转.gif","摇头.gif","眨眼.gif","吃东西.gif","弹肚皮.gif","动次打次.gif","比心心.gif","吹风.gif","打篮球.gif","都是小心心.gif","吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"]})}</script></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-md"><div class="container custom post-content mx-auto"><img src="/images/wechatpay.webp" class="rounded mx-auto d-block mt-5" style="width:120px;height:150px;vertical-align:-webkit-baseline-middle"><br><div style="text-align:center">买个卤蛋，吃根冰棒</div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><svg t="1586793095516" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3553" width="16" height="16"><path d="M512 0c282.7776 0 512 229.2224 512 512s-229.2224 512-512 512S0 794.7776 0 512 229.2224 0 512 0z m0 71.424a440.576 440.576 0 1 0 0 881.152 440.576 440.576 0 0 0 0-881.152z m8.192 166.7072c55.296 0 108.3904 15.5136 153.7536 44.2368a35.7376 35.7376 0 0 1-38.144 60.3648 215.6032 215.6032 0 0 0-115.5584-33.1264c-116.6336 0-210.6368 90.88-210.6368 202.3936s94.0032 202.3936 210.6368 202.3936c41.0112 0 80.2304-11.264 113.8688-32.1024a35.7376 35.7376 0 0 1 37.632 60.7744 287.1296 287.1296 0 0 1-151.552 42.8032c-155.4944 0-282.0608-122.368-282.0608-273.8688 0-151.552 126.5664-273.8688 282.112-273.8688z" fill="#8a8a8a" p-id="3554"></path></svg> <span itemprop="copyrightYear" id="cori">2021</span><br><svg t="1584375698087" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1913" width="23" height="14"><path d="M513.984496 513.984496c141.383442 0 256-114.616558 256-256S655.367938 1.984496 513.984496 1.984496 257.984496 116.601054 257.984496 257.984496s114.616558 256 256 256z m0-59.534884c-108.50431 0-196.465116-87.960806-196.465116-196.465116s87.960806-196.465116 196.465116-196.465116 196.465116 87.960806 196.465116 196.465116-87.960806 196.465116-196.465116 196.465116z" fill="#8a8a8a" p-id="1914"></path><path d="M1020.031008 992.248062c0-281.647628-227.423256-510.015504-508.031008-510.015504S3.968992 710.600434 3.968992 992.248062a29.767442 29.767442 0 1 0 59.534884 0c0-248.820093 200.827039-450.48062 448.496124-450.48062s448.496124 201.660527 448.496124 450.48062a29.767442 29.767442 0 1 0 59.534884 0z" fill="#8a8a8a" p-id="1915"></path></svg> <span class="author" id="cori" itemprop="copyrightHolder">Bryce Huang</span></div></div><script type="text/javascript" src="/js/commentTyping.min.js"></script></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:6,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="/js/custom.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","mysql基础知识&nbsp;"],cursorChar:"_",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>